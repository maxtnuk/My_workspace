trait is a lnaguage feature that tells the Rust compiler about functionality
a type must provide
it looks like the function prototype
here is the code 
'struct Circle{
	x: f64,
	y: f64,
	radius: f64,
}

trait HasArea {
	fn area(&self) -> f64;
}

impl HasArea for Circle{
	fn area(&self) -> f64{
		std::f64::consts::PI * (self.radius * self.radius)
	}
}'

we make the Circle and imply the function into it
trait have function prototype and imply the trait into the Circle
so Circle have the functions by trait
this feature would be usefule in generic generic is like c++ template
but in c++ template don't have the type's inner function 
so it is hard to generalize the type
but in rust solve the problums trait is also type but have the function 
prototype you can use the generic easily and it can provide its function to
each datastruct and use more effectively this is so awsome!!
and there is the rule of triat
1. if the trait isn't defined in your scope,it doesn't apply
   so if you use like this
   'let mut f =std::fs::File::open("foo.txt")
   .expect("Couldn't open foo.txt);
   let buf = b"whatever";
   let result = f.write(buf);' 
   that cause the error because you doesn't define the trait 'write'
   if you want to use this then add this code
   'use std::io::Write;' before we are here in guessing we see this 
   sentence now we know the meaning of it this means 'trait use'
2. either the trait or the type you're implementing it for must be defined 
   by you or more precisely ,one of them must be defined in the same crate
   as the impl you're writing 
   this means that if you implement the some datastruct by trait that 
   undifined in your scope that is forbiden in rust 
   so using 'impl' by undifined trait is illegal  
so rule 1 is for use and rule 2 is for implementing
if you want multiple trait then use like this
'fn foo<T: trait1 + trait2,K: trait3>(){}' so T now needs to be both 2traits
but foo function is not cool because '<>' is too long so there is the 
solution it is called a 'where clause' look at this code
'fn foo<T, K>(x: T,y: K) where T :trait1 + trait2, K: trait3'
it looks so readable it is usefule 
  	 
   
